<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Only Tilt Physics</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 10; pointer-events: none;
        }
        #btn {
            pointer-events: auto;
            padding: 20px 40px; background: white; color: black;
            font-size: 18px; font-weight: bold; border-radius: 40px; border: none;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        #debug {
            position: absolute; top: 10px; left: 10px; color: #0f0; 
            font-family: monospace; font-size: 14px; pointer-events: none;
            text-shadow: 1px 1px 1px black;
        }
    </style>
</head>
<body>

<div id="debug">Ожидание...</div>
<div id="ui"><button id="btn">ВКЛЮЧИТЬ ГИРОСКОП</button></div>
<canvas id="c"></canvas>

<script>
window.onload = () => {
    try {
        startApp();
    } catch(e) {
        alert("Ошибка: " + e.message);
    }
};

function startApp() {
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const debug = document.getElementById('debug');
    const btn = document.getElementById('btn');

    let W = window.innerWidth;
    let H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;

    // Параметры физики
    const COUNT = 800;
    const MAX_HEIGHT = H * 0.7; // Максимальная высота сугроба
    
    // Физика осыпания
    const REPOSE_SLOPE = 2; // Разница высот (пиксели), при которой снег лежит стабильно
    const SLIDE_SPEED = 0.4; // Как быстро течет снег (0.1 - медленно, 0.9 - как вода)

    let snow = [];
    let ground = new Float32Array(W).fill(0);
    
    let tilt = 0; // Наклон телефона (-1.0 ... 1.0)
    let windForce = 0;

    // --- СНЕЖИНКА ---
    class Flake {
        constructor(initY = false) {
            this.init(initY);
        }
        init(initY) {
            this.x = Math.random() * W;
            this.y = initY ? Math.random() * H : -10;
            this.z = Math.random(); 
            this.vy = 1 + this.z * 3; 
            this.vx = 0;
            this.size = 1.5 + this.z * 2;
        }
        update() {
            // Ветер сносит снежинки
            this.vx += (windForce - this.vx) * 0.1;
            this.x += this.vx;
            this.y += this.vy;

            // Стенки (не зацикливаем, а ограничиваем, раз панорамы нет)
            // Или зацикливаем для красоты потока? Давайте зацикливать по X, но не землю.
            if(this.x > W) this.x = 0;
            if(this.x < 0) this.x = W;

            // Столкновение
            let gx = Math.floor(this.x);
            if(gx >= 0 && gx < W) {
                let groundY = H - ground[gx];
                if(this.y >= groundY) {
                    // Упала
                    ground[gx] += 1.0; // Наращиваем сугроб
                    if(ground[gx] > MAX_HEIGHT) ground[gx] = MAX_HEIGHT;
                    this.init(false);
                }
            }
            if(this.y > H + 50) this.init(false);
        }
        draw() {
            ctx.fillStyle = `rgba(255,255,255,${0.5+this.z*0.5})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.fill();
        }
    }

    // --- ФИЗИКА ЗЕМЛИ (ЛАВИНА) ---
    function updateGroundPhysics() {
        // Мы проходим по земле и смотрим, не слишком ли крутой склон.
        // Если склон крутой, пересыпаем снег соседу.
        // tilt влияет на то, что считается "ровным". Если наклон вправо, то ровная поверхность для нас - это спуск вправо.
        
        // tiltBias: насколько пикселей сосед может быть ниже/выше из-за наклона
        // При наклоне 45 градусов (tilt=1), bias будет большой, заставляя снег течь.
        let bias = tilt * 8; 

        // Проход слева направо (для сдвига вправо)
        for(let i=0; i < W-1; i++) {
            let h1 = ground[i];
            let h2 = ground[i+1];
            
            // Если h1 выше h2 (с учетом наклона), снег течет от i к i+1
            // h1 должен быть не просто выше, а выше чем "угол покоя" + наклон
            if (h1 > h2 + REPOSE_SLOPE - bias) {
                let flow = (h1 - h2 - REPOSE_SLOPE + bias) * SLIDE_SPEED;
                ground[i] -= flow;
                ground[i+1] += flow;
            }
        }

        // Проход справа налево (для сдвига влево)
        for(let i=W-1; i > 0; i--) {
            let h1 = ground[i];
            let h2 = ground[i-1];
            
            // bias работает наоборот при движении влево
            if (h1 > h2 + REPOSE_SLOPE + bias) {
                let flow = (h1 - h2 - REPOSE_SLOPE - bias) * SLIDE_SPEED;
                ground[i] -= flow;
                ground[i-1] += flow;
            }
        }
        
        // Граничные условия (чтобы снег не уползал за экран бесконечно или не копился стеной)
        // Пусть утекает в "бездну" по краям
        ground[0] *= 0.95; 
        ground[W-1] *= 0.95;
    }

    // --- ГИРОСКОП ---
    function handleOrientation(e) {
        // Gamma: наклон влево (-90) / вправо (+90)
        let g = e.gamma || 0;
        
        // Ограничиваем угол от -45 до 45 для удобства
        if (g > 45) g = 45;
        if (g < -45) g = -45;

        // Нормализуем к диапазону -1...1
        tilt = g / 45; 
        
        // Ветер просто следует за наклоном
        windForce = tilt * 5; 

        debug.innerText = `Наклон: ${g.toFixed(0)}°\nВетер: ${windForce.toFixed(1)}`;
    }

    // Loop
    function animate() {
        ctx.fillStyle = '#080d15';
        ctx.fillRect(0, 0, W, H);

        updateGroundPhysics();

        // Рисуем землю
        ctx.fillStyle = '#eef';
        ctx.beginPath();
        ctx.moveTo(0, H);
        for(let i=0; i<W; i+=2) { // шаг 2 для оптимизации
            ctx.lineTo(i, H - ground[i]);
        }
        ctx.lineTo(W, H);
        ctx.fill();

        // Снежинки
        for(let s of snow) {
            s.update();
            s.draw();
        }

        requestAnimationFrame(animate);
    }

    // Init
    for(let i=0; i<COUNT; i++) snow.push(new Flake(true));
    
    // Кнопка
    btn.onclick = async () => {
        btn.parentElement.style.display = 'none';
        debug.innerText = "Запрос...";
        
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const r = await DeviceOrientationEvent.requestPermission();
                if(r === 'granted') {
                    window.addEventListener('deviceorientation', handleOrientation);
                    debug.innerText = "Работает (iOS)";
                } else {
                    alert("Нужен доступ!");
                }
            } catch(e) { alert(e); }
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
            debug.innerText = "Работает (Android)";
        }
    };

    window.onresize = () => {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        ground = new Float32Array(W).fill(0);
    };

    animate();
}
</script>
</body>
</html>
